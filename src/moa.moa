def main {
  match(io.argv[0]
    "build"   build()
    "c"       io.puts(genc(load()))
    "js"      io.puts(genjs(load()))
    "env"     env(io.argv[1])
    "ide"     ide(io.argv[1] || "9080")
    "repl"    repl()
    "run"     run("-DDEBUG")
    "test"    run("-DTEST")
    "version" io.puts("moa0.0.1 (Bun)")
    _         io.puts("Moa is a programming language

Usage: moa <command> [...arguments]

Commands:
  moa build [...files]     compile to an executable file
  moa c     [...files]     compile to C programming language
  moa env   [version]      switch to a selected version
  moa ide   [port=9080]    launch IDE in the browser
  moa repl  [...files]     start a shell
  moa run   [...files]     compile and run
  moa test  [...files]     run tests
  moa version              display Moa version"))
}

def load infer(io.glob("**/*.moa").fmap(fn(path parse(tokenize(io.reads(path) path)))))

def build ...args {
  let c genc(load())
  io.write("/tmp/a.c" c)
  io.shell("cc" "/tmp/a.c" "-O3" "-o" "a" ...args)
}

def run ...args {
  build ...args
  io.shell("./a")
}

def env version {
  if version {
    let mpath "~/.moa/bin/moa"
    let vpath "~/.moa/bin/" + version
    if !io.exists(vpath) {
      let url "https://github.com/moalang/moa/archive/refs/tags/" + version + "-" + io.os + "-" + io.arch
      io.write(vpath io.http.get(url))
    }
    io.rm(mpath)
    io.ln(vpath mpath)
    return
  }
  io.puts(io.glob("~/.moa/bin/*"))
}

def ide port {
  io.http.listen port io.embed("./ide").add("moa.js" genjs(load()))
}

def repl {
  let context load()
  io.readline "> " fn(r {
    if ":q :quit :e :exit".split(" ").has(r.line) {
      r.exit "Bye"
    }
    r.puts(eval(r.line context))
  })
}

struct Token {
  code   string
  offset int
  indent int
  lineno int
  column int
  op1    bool
  op2    bool
  call   bool
  index  bool
}

def tokenize program path {
  var offset 0
  var indent 0
  var lineno 1
  var column 0
  var tokens []
  let reg r/(r\/(?:[^\/\\]|\\.)*\/|[A-Za-z_][A-Za-z0-9_]*|[0-9]+(?:\.[0-9]+)|"[^"]*?"|`[^`]*?`|[ \r\n\t]+|[()\[\]{};]|#[^\n]*)/
  each code program.split(reg) {
    if code == "" || " \r\n\t#;".has(code[0]) {
      if code.has("\n") {
        let a = code.split("\n")
        indent = a[-1].size
        lineno += a.size - 1
        column = indent
      } else {
        column += code.size
      }
    } else {
      let op r/^[+\-*\/%|&<>=!]+$/.test(code) && code != "=>"
      let lc iif(offset > 0 program[offset - 1] "")
      let rc program[offset + code.length]
      let op1 (op || code === "...") && r/[A-Za-z0-9_\]]/.test(rc)
      let op2 op && !op1
      let adj r/[A-Za-z0-9_"\])]/.test(lc)
      let call code == "(" && adj
      let index code == "[" && adj
      tokens.push(Token(code offset indent lineno column op1 op2 call index))
      column += code.size
    }
    offset += code.size
  }
  return tokens
}

struct Type {
  name     string
  generics vec[Type]
}

struct Node {
  token Token
  argv  vec[Node]
  type  Type
}

def parse tokens {
  var pos 0
  let untype Type("0" [])
  let untoken Token("" 0 0 0 0 false false false false)
  def nodetoken t Node(t [] untype)
  def nodecall  t a Node(t a untype)
  def nodeapply a Node(untoken a untype)
  def fake code t Token(code t.offset t.indent t.lineno t.column false false false false)
  def until f g {
    var nodes []
    while pos < tokens.size && f(tokens[pos]) {
      nodes.push(g())
    }
    return nodes
  }
  def untilby code g drop(pos code until(fn(t t.code != code) g))
  def drop start code ret {
    assert pos < tokens.size `No close '${code}' from ${tokens[start].offset}`
    assert tokens[pos].code == code
    pos += 1
    return ret
  }
  def bottom {
    def link node {
      if pos < tokens.size {
        let t tokens[pos]
        if t.code === "." {
          pos += 1
          let field nodetoken(tokens[pos])
          pos += 1
          return link(nodecall(t [node field]))
        } else if t.index {
          pos += 1
          return link(nodeapply([nodecall(fake("." t) [node nodetoken(fake("at" t))]) ...untilby("]" bottom)]))
        } else if t.call {
          pos += 1
          if node.argv.size == 0 {
            return link(nodecall(node.token untilby(")" bottom)))
          } else {
            return link(nodeapply([node].concat(untilby(")" bottom))))
          }
        } else if t.op2 {
          pos += 1
          return link(nodecall(t [node bottom()]))
        }
      }
      return node
    }
    let t tokens[pos]
    pos += 1
    return iif(
      t.code === "(" link(nodecall(t untilby(")" bottom)))
      t.code === "[" link(nodecall(t untilby("]" bottom)))
      t.code === "{" link(nodecall(t untilby("}" line)))
      t.op1          link(nodecall(t [bottom()]))
      link(nodetoken(t)))
  }
  def line {
    let lineno tokens[pos].lineno
    return squash(until(fn(t lineno == t.lineno && t.code != "}") bottom))
  }
  def squash a iif(a.size == 1 a[0]
    a[0].token.code == "" nodeapply(a)
    nodecall(a[0].token a.slice(1)))
  return until(fn(t t.code != "}") line)
}

def infer root {
  return root
}

def genc root {
  return `#include <stdio.h>
int main() {
  puts("moa0.0.1");
  return 0;
}
`
}

def genjs root {
  def gencode s {
    return iif(
      s == `"` || s == "`"  JSON.stringify(s.slice(1 -1)).replaceAll(r/\\\\/g "\\")
      s == "["              "[]"
      s.starts("r/")        s.slice(1)
      s)
  }
  def genmatch a {
    return iif(a.size
    "__target === " + a[0] + " ? " + a[1] + ":" + genmatch(a.slice(2))
    fail(`No match ${__target}`))
  }
  def geniif = a {
    return iif(
    a.length === 0 "(() => { throw new Error(`No default in if`)})()"
    a.length === 1 a[0]
    a[0] + " ? " + a[1] + " :\n  " + geniif(a.slice(2)))
  }
  def genstruct a {
    return "(" + a + ") => ({" + a + "})"
  }
  def genapply head tail {
    return iif(
      head.op1                                     head.code + gen(tail[0])
      head.op2                                     gen(tail[0]) + " " + head.code + " " + gen(tail[1])
      head.code == "."                             "__prop(" + gen(tail[0]) + ", " + JSON.stringify(gen(tail[1])) + ")"
      head.code == "fn"                            "0 || ((" + tail.slice(0 -1).map(gen).join(", ") + ") => " + gen(tail.at(-1)) + ")"
      head.code == "var"                           "let "   + gen(tail[0]) + " = " + gen(tail.at(-1))
      head.code == "let"                           "const " + gen(tail[0]) + " = " + gen(tail.at(-1))
      head.code == "def"                           "const " + gen(tail[0]) + " = (" + tail.slice(1 -1).map(gen).join(",") + ") => " + gen(tail.at(-1))
      head.code == "test"                          "__tests.push(() => " + gen(tail[0]) + ")"
      head.code == "struct"                        "const " + gen(tail[0]) + " = " + genstruct(tail[1].argv.map(fn(f f.token.code)).join(","))
      head.code == "each"                          "for (const " + gen(tail[0]) + " of " + gen(tail[1]) + ") " + gen(tail[2])
      head.code == "while"                         "while (" + gen(tail[0]) + ") " + gen(tail[1])
      head.code == "if"                            "if (" + gen(tail[0]) + ")" + gen(tail[1])
      head.code == "else" && gen(tail[0]) === "if" "else if (" + gen(tail[1]) + ") " + gen(tail[2])
      head.code == "else"                          "else " + gen(tail[0])
      head.code == "iif"                           "0 || (" + geniif(tail.map(gen).join(",")) + ")"
      head.code == "match"                         "0 || (__target => " + genmatch(tail.slice(1).map(gen).join(",")) + ")(" + gen(tail[0]) + ")"
      head.code == "("                             "(" + gen(tail[0])   + ")"
      head.code == "["                             "[" + tail.map(gen).join(", ")  + "]"
      head.code == "{"                             "{\n" + genjs(tail) + "\n" + "}"
      head.code + "(" + tail.map(gen).join(",") + ")")
  }
  def gen node {
    return iif(
      node.argv.size == 0    gencode(node.token.code)
      node.token.code != ""  genapply(node.token node.argv)
      gen(node.argv[0]) + "(" + node.argv.slice(1).map(gen).join(",") + ")")
  }
  return root.map(gen).join(";\n").gsub("};\nelse"  "} else")
}

def eval code root {

}

test {
  def js s {
    return genjs(infer(parse(tokenize(s ""))))
  }

  # value
  assert js("1")     == "1"
  assert js("1.2")   == "1.2"
  assert js("true")  == "true"
  assert js(`"hi"`)  == `"hi"`
  assert js("r/1/")  == "/1/"
  assert js("[]")    == "[]"
  assert js("[1]")   == "[1]"
  assert js("[1 2]") == "[1, 2]"
  assert js("fn a a") == "0 || ((a) => a)"
  assert js("fn(a b a + b)") == "0 || ((a, b) => a + b)"

  # unray operator
  assert js("-1") == "-1"

  # binary operator
  assert js("1 + 2") == "1 + 2"
  assert js("1 + (2 * 3)") == "1 + (2 * 3)"

  # function call
  #assert js("fn(a a) 1") == "(0 || ((a) => a))(1)"

  # assert
  assert "assert true", "assert(true, 1)"
  assert "\nassert true", "assert(true, 2)"

  # edge case
  assert js(`"\\"`).size == 3
}

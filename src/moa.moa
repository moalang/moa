class type:
  tname str
  targs vec[type]

class token:
  code   str
  offset int
  lineno int
  indent int

class ast:
  head token
  tail vec[ast]
  type type

let stmt = token("stmt" 0 0 0)

dec compile: str str
def compile moa:
  let nodes = parse(moa)
  infer nodes
  return gen(nodes)

dec tokenize: str vec[token]
def tokenize moa:
  var lineno = 1
  var indent = 0
  var tokens = []
  var i = 0
  let size = moa.size
  while i < moa.size:
    let offset = i
    let c = moa[i]
    var s = ""
    if c == " " || c == "\n":
      while i < size && (moa[i] == " " || moa[i] == "\n"):
        s += moa[i]
        i += 1
      lineno += s.split("\n").size - 1
      indent += iif(s.has("\n") s.split("\n").at(-1).size indent)
    else if (("A" <= c) && (c <= "Z")) || (("a" <= c) && (c <= "z")) || c == "_":
      while (i < size) && ((("A" <= c) && (c <= "Z")) || (("a" <= c) && (c <= "z")) || c == "_"):
        s += moa[i]
        i += 1
      tokens.push(token(s offset lineno indent))
    else:
      throw "Unknown charactor " + c
#  for (const code of moa.split(/([ \n]+|[()\[\]{}]|[0-9+]+\.[0-9]+|[:.+\-*/%!=^|&?><]+|"[^"]*"|`[^`]*`|[ \n]+)/)) {
#    if (code.trim()) {
#      const op1 = code === "!"
#      const op2 = "+-*/%|&<>=!".includes(code[0])
#      tokens.push({code, lineno, offset, indent, ...(op1 && {op1}), ...(op2 && {op2})})
#    }
#    offset += code.length
#    lineno += code.split("\n").length - 1
#    indent = code.includes("\n") ? code.split("\n").at(-1).length : indent
#  }
#  return tokens
  log tokens
  return []

dec parse: vec[token] ast
def parse moa:
  let nodes = tokenize(moa)
  return nodes

dec infer: ast void
def infer nodes:
  return

dec gen: ast str
def gen nodes:
  return `package main\n\nimport "fmt"\nfunc main() { fmt.Println("moa-go") }`

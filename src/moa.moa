def main {
  match(io.argv[0]
    "build"   build()
    "c"       io.puts(genc(load()))
    "js"      io.puts(genjs(load()))
    "env"     env(io.argv[1])
    "ide"     ide(io.argv[1] || "9080")
    "repl"    repl()
    "run"     run("-DDEBUG")
    "test"    run("-DTEST")
    "version" io.puts("moa0.0.1 (Bun)")
    _         io.puts("Moa is a programming language

Usage: moa <command> [...arguments]

Commands:
  moa build [...files]     compile to an executable file
  moa c     [...files]     compile to C programming language
  moa env   [version]      switch to a selected version
  moa ide   [port=9080]    launch IDE in the browser
  moa repl  [...files]     start a shell
  moa run   [...files]     compile and run
  moa test  [...files]     run tests
  moa version              display Moa version"))
}

def load {
  infer io.glob("**/*.moa").fmap(fn(path parse(tokenize(io.reads(path) path))))
}

def build ...args {
  let c genc(load())
  io.write "/tmp/a.c" c
  io.shell "cc" "/tmp/a.c" "-O3" "-o" "a" ...args
}

def run ...args {
  build ...args
  io.shell "./a"
}

def env version {
  if version {
    let mpath "~/.moa/bin/moa"
    let vpath "~/.moa/bin/" + version
    if !io.exists vpath {
      io.write vpath io.http.get("https://github.com/moalang/moa/archive/refs/tags/" + version + "-" + io.os + "-" + io.arch)
    }
    io.rm mpath
    io.ln vpath mpath
    return
  }
  io.puts io.glob("~/.moa/bin/*")
}

def ide port {
  io.http.listen port io.embed("./ide").add("moa.js" genjs(load()))
}

def repl {
  let context load()
  io.readline "> " fn(r {
    if ":q :quit :e :exit".split(" ").has r.line {
      r.exit "Bye"
    }
    r.puts eval(r.line context)
  })
}

struct Token {
  code   string
  offset int
  indent int
  lineno int
  column int
  op1    bool
  op2    bool
  call   bool
  index  bool
}

def tokenize program path {
  var offset 0
  var indent 0
  var lineno 1
  var column 0
  var tokens []
  let reg r/(r\/(?:[^\/\\]|\\.)*\/|[A-Za-z_][A-Za-z0-9_]*|[0-9]+|"[^"]*?"|`[^`]*?`|[ \r\n\t]+|[()\[\]{};]|#[^\n]*)/
  each code program.split(reg) {
    if code == "" || " \r\n\t#;".has(code[0]) {
      if code.has("\n") {
        let a = code.split("\n")
        indent = a[-1].size
        lineno += a.size - 1
        column = indent
      } else {
        column += code.size
      }
    } else {
      let op r/^[+\-*\/%|&<>=!]+$/.test(code) && code != "=>"
      let lc iif(offset > 0 program[offset - 1] "")
      let rc program[offset + code.length]
      let op1 (op || code === "...") && r/[A-Za-z0-9_\]]/.test(rc)
      let op2 op && !op1
      let adj r/[A-Za-z0-9_"\])]/.test(lc)
      let call code == "(" && adj
      let index code == "[" && adj
      tokens.push Token(code offset indent lineno column op1 op2 call index)
      column += code.size
    }
    offset += code.size
  }
  return tokens
}

def parse tokens {
  var pos 0
  def fake code t Token(code t.offset t.indent t.lineno t.column false false false false)
  def until f g {
    var nodes []
    while pos < tokens.size && f(tokens[pos]) {
      nodes.push(g())
    }
    return nodes
  }
  def untilby code g drop(pos code until(fn(t t.code != code) g))
  def drop start code ret {
    assert pos < tokens.size `No close '${code}' from ${tokens[start].offset}`
    assert tokens[pos].code == code
    pos += 1
    return ret
  }
  def bottom {
    def link t {
      if pos < tokens.size {
        let u tokens[pos]
        if u.code === "." {
          pos += 1
          let field tokens[pos]
          pos += 1
          return link([u t field])
        } else if u.index {
          pos += 1
          return link([[fake("." u) t fake("at" u)] ...untilby("]" bottom)])
        } else if u.call {
          pos += 1
          return link([t].concat(untilby(")" bottom)))
        } else if u.op2 {
          pos += 1
          return link([u t bottom()])
        }
      }
      return t
    }
    t = tokens[pos]
    pos += 1
    return iif(
      t.code === "(" link([t ...untilby(")" bottom)])
      t.code === "[" link([t ...untilby("]" bottom)])
      t.code === "{" link([t ...untilby("}" line)])
      t.op1          link([t bottom()])
      link(t))
  }
  def line {
    let lineno tokens[pos].lineno
    return squash(until(fn(t lineno == t.lineno && t.code != "}") bottom))
  }
  def top until(fn(t t.code != "}") line)
  def squash a iif(a.size == 1 a[0] a)
  return top()
}

def infer root {
}
def genc root {
  return `#include <stdio.h>
int main() {
  puts("moa0.0.1");
  return 0;
}
`
}
def genjs root {
  return `console.log("moa js")`
}
def eval code root {}

#!node
"use strict"

// Expression
// - [x] bool literal
// - [x] int literal
// - [x] float literal
// - [x] string literal
// - [x] fn
// - [x] tuple
// - [x] new
// - [x] vec
// - [x] set
// - [x] map
// - [x] operators
// - [x] throw
// - [x] catch
// - [x] iif
// Declare
// - [x] let
// - [x] struct
// Statement
// - [x] do
// - [x] if
// - [x] for
// - [x] each
// - [x] while
// - [x] continue, break
// IO
// - [x] io
// Test
// - [ ] type inference
// - [ ] generate complex code

const log = x => { console.dir(x, {depth: null}); return x }
const show = x => Array.isArray(x) ? `(${x.map(show).join(" ")})` : x.code
const range = n => [...new Array(n)].map((_, i) => i)

const tokenize = code => code.split(/([()]|[^\n ()]+)/).filter(s => s.trim()).map(s => ({code: s}))

const parse = ([t, ...ts], acc=[]) =>
  !t ? acc :
  t.code === ")" ? [acc, parse([ts])] :
  t.code === "(" ? (([x, rest]) => parse(rest, acc.concat([x])))(parse(ts)) :
  parse(ts, acc.concat(t))

class TypeError extends Error { }

const infer = root => {
  let varId = 0
  const newtype = (name, args=[]) => ({name, args})
  const newvar = () => ({...newtype(varId++), var: true})
  const newfn = (args, names, ret) => ({...newtype("fn", args), names, ret})
  const newstruct = args => ({...newfn(args), struct: true})
  const newtuple = args => newtype("tuple", args)
  const newnew = fields => ({...newtype("new", fields.map(a => a.type)), fields})
  const newvec = t => newtype("vec", [t])
  const newset = t => newtype("set", [t])
  const newmap = (k, v) => newtype("map", [k, v])
  const newvargs = vargs => ({...newtype("__varg"), vargs})

  const fails = t => ({...t, fails: true})
  const optional = t => ({...t, optional: true})
  const property = (t, name) => (t.props ||= {}, t.props[name] = newvar())

  const prune = x => x.instance ? x.instance = prune(x.instance) : x
  const tvoid = newtype("struct{}")
  const tbool = newtype("bool")
  const tint = newtype("int")
  const tfloat = newtype("float64")
  const tstring = newtype("string")
  const terror = newtype("error")
  const tio = newtype("io")
  const tv1 = newvar()
  const env = {
    "!": newfn([tbool, tbool]),
    "return": newfn([tv1, tv1]),
    "if": newfn([newvargs([tbool, tv1]), optional(tv1), tvoid]),
    "iif": newfn([newvargs([tbool, tv1]), tv1, tv1]),
    "throw": fails(newfn([tv1, fails(newvar())])),
    "catch": newfn([tv1, newfn([terror, tv1]), tv1]),
    "while": newfn([tbool, tv1, tvoid]),
    "bool": tbool,
    "int": tint,
    "float": tfloat,
    "string": tstring,
    "continue": tvoid,
    "break": tvoid,
    "io": tio,
  }

  const method = (t, field) =>
    t.var ? property(t, field) :
    t.name === "tuple" && field < t.args.length ? t.args[field] :
    t.name === "error" && field === "message" ? tstring :
    t.name === "io" && field === "put" ? newfn([tv1, tv1]) :
    t.fields?.find(f => f.code === field).type ||
    (() => { throw new TypeError(`No ${field} in ${t.name}${t.args.length ? `[${t.args}]` : ''}`) })()
  const unify = (a, b) => {
    a = prune(a)
    b = prune(b)
    if (a.var) {
      a.instance = b
      if (a.props) {
        if (b.var) {
          b.props = {...(b.props||={}), ...a.props}
        } else {
          Object.keys(a.props).map(name => unify(a.props[name], method(b, name)))
        }
      }
    } else if (b.var) {
      unify(b, a)
    } else {
      if (a.name !== b.name) {
        throw new TypeError(`Type name ${a.name} != ${b.name}`)
      }
      if (a.args.length !== b.args.length) {
        throw new TypeError(`Type args ${a.args} != ${b.args}`)
      }
      a.args.map((x, i) => unify(x, b.args[i]))
    }
  }
  const safeUnify = (a, b) => {
    try {
      unify(a, b)
    } catch (e) {
      if (e instanceof TypeError) {
        return false
      } else {
        throw e
      }
    }
    return true
  }
  const apply = (f, args) => {
    let i = 0
    for (const fa of f.args.slice(0, -1)) {
      if (fa.name === "__varg") {
        while (args[i]) {
          let k = i
          if (!fa.vargs.every(t => args[i] && safeUnify(t, args[i++]))) {
            i = k
            break
          }
        }
      } else if (fa.optional) {
        if (args[i] && !safeUnify(fa, args[i++])) {
          i--
        }
      } else {
        unify(fa, args[i++])
      }
    }
    if (i !== args.length) {
      throw new Error(`Calling vargs ${JSON.stringify(f.args)} != ${JSON.stringify(args)}`)
    }
    return f.args.at(-1)
  }
  const fresh = (type, nonGeneric) => {
    const d = {}
    const rec = t => {
      const u = prune(t)
      return u.var ?
        (nonGeneric.includes(u.name) ? u : d[u.name] ||= newvar()) :
        (v => (type.generics.push(v.args), v))({...u, args: u.args.map(rec)})
    }
    type.generics ||= []
    return rec(type)
  }
  const islogical = s => s === "||" || s === "&&"
  const isFail = a => Array.isArray(a) ? a[0].code === "throw" || a.some(isFail) : false
  const returnType = a => Array.isArray(a) ? (a.find(x => x[0]?.code === "return")?.[1]?.type || a.reduce((acc, x) => acc || returnType(x), null)) : tvoid
  const inferWith = (top, env, nonGeneric) => {
    const _inf = node => {
      if (Array.isArray(node)) {
        const head = node[0]
        const tail = node.slice(1)
        if (Array.isArray(head)) {
          return apply(inf(head), tail.map(inf))
        } else {
          const s = head.code
          if (s === "do") {
            tail.map(inf)
            const ret = returnType(tail)
            return isFail(tail) ? fails(ret) : ret
          } else if (s === "let") {
            return env[tail[0].code] = inf(tail[1])
          } else if (s === "struct") {
            const [t, ...ts] = tail
            const args = range(ts.length / 2).map(i => (ts[i*2].type = inf(ts[i*2+1]), ts[i*2]))
            return env[t.code] = newstruct(args.map(a => a.type).concat(newnew(args)))
            return t
          } else if (s === "fn") {
            const args = tail.slice(0, -1).map(t => [t.code, t.type = newvar()])
            const body = inferWith(tail.at(-1), {...env, ...Object.fromEntries(args)}, nonGeneric.concat(args.map(a => a[1].name)))
            return newfn([...args.map(a => a[1]), body], tail.slice(0, -1), tail.at(-1))
          } else if (s === "for") {
            tail[0].type = tint
            tail.slice(1, 1).map(node => unify(tint, inf(node)))
            inferWith(tail.at(-1), {...env, ...{[tail[0].code]: tint}}, nonGeneric)
            return tvoid
          } else if (s === "each") {
            tail[0].type = newvar()
            tail.slice(1, -1).map(inf)
            inferWith(tail.at(-1), {...env, ...{[tail[0].code]: tail[0].type}}, nonGeneric)
            return tvoid
          } else if (s === "tuple") {
            return newtuple(tail.map(inf))
          } else if (s === "new") {
            return newnew(range(tail.length / 2).map(i => (tail[i*2].type = inf(tail[i*2+1]), tail[i*2])))
          } else if (s === "vec") {
            return newvec(same(tail))
          } else if (s === "set") {
            return newset(same(tail))
          } else if (s === "map") {
            const keys = range(tail.length / 2).map(i => inf(tail[i*2]))
            const values = range(tail.length / 2).map(i => inf(tail[i*2+1]))
            return newmap(keys[0], values[0])
          } else if (islogical(s)) {
            return same(tail)
          } else if ("+-*/%^=<>!".includes(s[0])) {
            same(tail)
            return "== != < > >= <=".split(" ").includes(s) ? tbool : tail.map(inf).at(-1)
          } else if (s === ".") {
            const target = inf(tail[0])
            if (target.name === "tuple") {
              return target.args[tail[0].code]
            } else {
              tail.slice(2).map(inf)
              return method(target, tail[1].code)
            }
          } else {
            return apply(inf(head), tail.map(inf))
          }
        }
      } else {
        const s = node.code
        return /^[0-9]+\./.test(s)      ? tfloat :
          /^[0-9]+/.test(s)             ? tint :
          s === "true" || s === "false" ? tbool :
          s.startsWith('"')             ? tstring :
          s in env ? fresh(env[s], nonGeneric) :
          (() => { throw new Error(`Type literal '${s}'`) })()
      }
    }
    const inf = node => node.type ||= _inf(node)
    const same = a => (([x, ...ts]) => (ts.map(t => unify(t, x)), x))(a.map(inf))
    return inf(top)
  }
  const fix = node => {
    if (Array.isArray(node)) {
      node.map(fix)
    }
    if (node.type) {
      node.type = prune(node.type)
      node.type.args = node.type.args.map(prune)
      if (node.type.generics) {
        const d = {}
        for (const a of node.type.generics) {
          const t = a.map(prune)
          d[JSON.stringify(t)] ||= t
        }
        node.type.generics = Object.values(d)
      }
    }
  }

  root.map(node => inferWith(node, env, [tv1.name]))
  root.map(fix)
  return root
}

const generate = root => {
  let id = 0
  const newId = () => `__${id++}`
  const defs = []
  const lines = []
  const genreturn = x => {
    const ret = generate([x])
    return x[0]?.code === "do" ? ret.stmt + "\n" + ret.exp : `${ret.stmt}\nreturn ${ret.exp}`
  }
  const genop = (op, xs) => xs.length === 1 ? `${op} ${gen(xs[0])}` : genop2(op, xs)
  const genop2 = (op, xs) => xs.length === 1 ? gen(xs[0]) : `${gen(xs[0])} ${op} ${genop2(op, xs.slice(1))}`
  const gentype = t => t.args.length === 0 ? t.name :
    t.name === "tuple" ? `__${t.name}${t.args.length}[${t.args.map(gentype)}]` :
    t.name === "new" ? genstruct(t) :
    `${t.name}[${t.args.map(gentype)}]`
  const genstruct = t => `struct { ${t.fields.map(f => `${f.code} ${gentype(f.type)}`).join("\n")} }`
  const genfunc = (t, name="") => `func ${name}(${t.names.map(a => `${a.code} ${gentype(a.type)}`)}) (__ret ${gentype(t.ret.type)}${t.ret.type.fails ? ', __err error' : ''})`
  const geniif = (id , a) => a.length === 1 ? `{ ${id} = ${gen(a[0])} }` : `if ${gen(a[0])} { ${id} = ${gen(a[1])} } else ${geniif(id, a.slice(2))}`
  const genif = a =>
    a.length === 0 ? "" :
    a.length === 1 ? ` else { ${gen(a[0])} }` :
    ` else if ${gen(a[0])} { ${gen(a[1])} } ${genif(a.slice(2))}`
  const genfor = ([a, b, c, d, e]) =>
    e ? `for ${a} := ${b}; ${a} < ${c}; ${a} += ${d} { ${e} }` :
    d ? `for ${a} := ${b}; ${a} < ${c}; ${a}++ { ${d} }` :
    c ? `for ${a} := 0; ${a} < ${b}; ${a}++ { ${c} }` :
    (() => {throw new Error(`genfor ${a}, ${b}, ${c}, ${d}, ${e}`)})()
  const genlet = (name, body) => {
    if (body[0]?.code === "fn" && body.type.args.find(x => x.var) && body.type.generics.length) {
      for (const a of body.type.generics) {
        const x = structuredClone(body)
        x.type = {...x.type, args: a}
        x.slice(1, -1).map((arg, i) => arg.type = a[i])
        x.type.names.map((arg, i) => arg.type = a[i])
        x.type.ret.type = a.at(-1)
        lines.push(`${name}__${a.map(gentype).join("__")} := ${gen(x)}`)
      }
    } else {
      lines.push(`${name} := ${gen(body)}`)
    }
    return ""
  }
  const genhead = x => x.type.name === "fn" && x.type.names?.find(y => y.type.var) && x.type.generics?.length ?
    `${gen(x)}__${x.type.args.map(gentype).join("__")}` : gen(x)
  const gen = x => !Array.isArray(x) ? x.code :
    x[0].code === "do"     ? x.slice(1).map(gen).join("\n") :
    x[0].code === "for"    ? (lines.push(genfor(x.slice(1).map(gen))), "") :
    x[0].code === "each"   ? (lines.push(`for _, ${x[1].code} := range ${gen(x[2])} { ${gen(x[3])} }`), "") :
    x[0].code === "while"  ? (lines.push(`for ${gen(x[1])} { ${gen(x[2])} }`), "") :
    x[0].code === "let"    ? genlet(x[1].code, x[2]) :
    x[0].code === "return" ? `__ret = ${gen(x[1])}; return` :
    x[0].code === "throw"  ? `__err = errors.New(${gen(x[1])}); return` :
    x[0].code === "catch"  ? !x[1].type.fails ? gen(x[1]) : ((id1, id2) => (lines.push(`${id1}, ${id2} := ${gen(x[1])}; if ${id2} != nil { ${id1} = ${gen(x[2])}(${id2}) }`), id1))(newId(), newId()) :
    x[0].code === "if"     ? `if ${gen(x[1])} { ${gen(x[2])} }${genif(x.slice(3))}` :
    x[0].code === "iif"    ? (id => (lines.push(`var ${id} ${gentype(x[2].type)}; ${geniif(id, x.slice(1))}`), id))(newId()) :
    x[0].code === "struct" ? (defs.push(`type ${x[1].code} ${genstruct(x.type.args.at(-1))}`), "") :
    x[0].code === "fn"     ? `${genfunc(x.type)} { ${genreturn(x.at(-1))} }` :
    x[0].code === "tuple"  ? `__tuple${x.length - 1}[${x.slice(1).map(node => gentype(node.type))}]{ ${x.slice(1).map(gen)} }` :
    x[0].code === "new"    ? `${genstruct(x.type)}{${range((x.length-1)/2).map(i => gen(x[i*2+2]))}}` :
    x[0].code === "vec"    ? `[]${gentype(x[1].type)}{ ${x.slice(1).map(gen)} }` :
    x[0].code === "map"    ? `map[${gentype(x[1].type)}]${gentype(x[2].type)}{ ${range((x.length-1)/2).map(i => `${gen(x[i*2+1])}: ${gen(x[i*2+2])}`)} }` :
    x[0].code === "set"    ? `map[${gentype(x[1].type)}]struct{}{ ${x.slice(1).map(n => `${gen(n)}: struct{}{}`)} }` :
    x[0].code === "!"      ? `${x[0].code} ${gen(x[1])}` :
    x[0].type?.struct      ?  gen(x[0]) + "{" + x.slice(1).map(gen).join(", ") + "}" :
    x[0].code === "." && x[1]?.type?.name === "tuple" ? `${gen(x[1])}.v${x[2].code}` :
    x[0].code === "." && x[1]?.type?.name === "error" && x[2].code === "message" ? `${gen(x[1])}.Error()` :
    /[+\-*/%^<>!=|&.]/.test(x[0].code) ? genop(x[0].code, x.slice(1)) :
    genhead(x[0]) + "(" + x.slice(1).map(gen).join(", ") + ")"
  const exp = root.map(gen).at(-1)
  return {
    def: defs.join("\n"),
    stmt: lines.join("\n"),
    exp: exp,
    fails: root.at(-1).type?.fails
  }
}

const compile = code => generate(infer(parse(tokenize(code))))

const testType = () => {
  const showType = type => {
    const show = t => t.instance ? show(t.instance) :
      t.name === "fn" ? '(' + t.args.map(show).join(' ') + ')' :
      t.name && t.args.length ? t.name + '[' + t.args.map(show).join(' ') + ']' :
      t.args.length ? '(' + t.args.map(show).join(' ') + ')' :
      t.name
    const s = show(type)
    const o = {}
    const r = s.replace(/\d+/g, t => o[t] ||= Object.keys(o).length + 1)
    return r
  }
  const reject = src => {
    try {
      infer(parse(tokenize(src)))
    } catch (e) {
      if (e instanceof TypeError) {
        return
      }
    }
    console.error('src:', src)
    process.exit(1)
  }
  const inf = (expect, src) => {
    try {
      const actual = showType(infer(parse(tokenize(src))).at(-1).type)
      if (actual !== expect) {
        console.error(`${expect} != ${actual}\n${src}`)
        process.exit(1)
      }
    } catch (e) {
      console.log(src)
      console.error(e)
      throw e
    }
  }
  inf('(1 1)', '(fn a a)')

  // primitives
  inf('int', '1')
  inf('bool', 'true')
  inf('bool', 'false')

  // exp
  inf('int', '(+ 1 1)')
  inf('bool', '(< 1 1)')

  // branch
  inf('int', '(iif true 1 2)')
  inf('bool', '(iif true true true)')

  // value
  inf('int', '((fn 1))')

  // simple function
  inf('(int int)', '(fn a (- a 1))')
  inf('(int int int)', '(fn a b (- a b 0))')

  // generics
  inf('(1 1)', '(fn a a)')
  inf('(1 2 1)', '(fn a b a)')
  inf('(1 2 2)', '(fn a b b)')
  inf('int', '((fn a a) 1)')
  inf('bool', '(let f (fn a a))(f 1)(f true)')

  // combinations
//  inf('int',                           'def f x (+ x 1); def g x (+ x 2); + (f 1) (g 1)')
//  inf('((1 2) (2 3) 1 3)',             'def _ f g x (g (f x))')
//  inf('((1 2 3) (1 2) 1 3)',           'def _ x y z (x z (y z))')
//  inf('(1 (1 bool) (1 1))',            'def _ b x (if (x b) x (def _ x b))')
//  inf('(bool bool)',                   'def _ x (if true x (if x true false))')
//  inf('(bool bool bool)',              'def _ x y (if x x y)')
//  inf('(1 1)',                         'def _ n ((def _ x (x (def _ y y))) (def _ f (f n)))')
//  inf('((1 2) 1 2)',                   'def _ x y (x y)')
//  inf('((1 2) ((1 2) 1) 2)',           'def _ x y (x (y x))')
//  inf('(1 ((1 2 3) 4 2) (1 2 3) 4 3)', 'def _ h t f x (f h (t f x))')
//  inf('((1 1 2) ((1 1 2) 1) 2)',       'def _ x y (x (y x) (y x))')
//  inf('(((1 1) 2) 2)',                 'def id x x; def f y (id (y id))')
//  inf('int',                           'def id x x; def f (if (id true) (id 1) (id 2))')
//  inf('int',                           'def f x (3); def g (+ (f true) (f 4))')
//  inf('(bool (1 1))',                  'def f x x; def g y y; def h b (if b (f g) (g f))')

  // declare function
//  inf('bool', 'dec f bool; f')
//  inf('int', 'dec _ int')
//  inf('(int bool)', 'dec _ int bool')
//  inf('(... int)', 'dec _ ... int')
//  inf('(1 1)', 'dec _[a] a a')
//  inf('(1 1 2)', 'dec _[a b] a a b')
//
//  // declare object
//  inf('(x.int)', 'dec _: x int')
//  inf('(x.1)', 'dec _[a]: x a')
//  inf('(f.(int int))', 'dec _: f int int')
//  inf('(x.1 f.(1 2 int))', 'dec _[a b]: x a; f a b int')
//
//  // variadic arguments
//  inf('(... int)', 'def f ... 1')
//  inf('int', 'def f ... 1; f 1')
//  inf('int', 'def f ... 1; f 1 true')
//  inf('(... 1)', 'def f ...a a')
//  inf('tuple[int]', 'def f ...a a; f 1')
//  inf('tuple[int bool]', 'def f ...a a; f 1 bool')
//  inf('bool', 'def f[t] ...[t] true; f 1 2')
//  inf('int', 'def f[t] ...[t] t; f 1 2')
//  inf('tuple[int bool int bool]', 'def f[t u] ...a[t u] a; f 1 true 2 false')
//
  // type errors
  reject("(+ 1 true)")
//  reject('def f[t] ...[t] true; f 1 true')
//  reject('def f[t u] ...[t u] true; f 1 true true')
}

const testMain = runGo => {
  const test = (expected, exp, define="") => {
    const src = define.length ? define + "\n" + exp : exp
    const go = compile(src)
    const actual = runGo(go)
    if (expected !== actual) {
      throw new Error(`${expected} != ${actual}\n# src\n${src}\n# go\n${go.def}\n${go.stmt}\n${go.exp}`)
    }
  }

  // Value
  test("true", "true")
  test("1", "1")
  test("1.2", "1.2")
  test("hi", '"hi"')
  test("{1}", "(tuple 1)")
  test("{1 2}", "(tuple 1 2)")
  test("{1}", "(new a 1)")
  test("{1 2}", "(new a 1 b 2)")
  test("[1]", "(vec 1)")
  test("[1 2]", "(vec 1 2)")
  test("[true]", "(vec true)")
  test("map[1:true]", "(map 1 true)")
  test("map[1:true 2:false]", "(map 1 true 2 false)")
  test("map[1:{}]", "(set 1)")
  test("map[1:{} 2:{}]", "(set 1 2)")

  // Operator
  test("false", "(! true)")
  test("-1", "(- 1)")
  test("-2", "(^ 1)")
  test("3", "(+ 1 2)")
  test("1", "(- 3 2)")
  test("6", "(* 2 3)")
  test("2", "(/ 4 2)")
  test("1", "(% 3 2)")
  test("3", "(^ 1 2)")
  test("true", "(== 1 1)")
  test("false", "(!= 1 1)")
  test("false", "(< 1 1)")
  test("false", "(> 1 1)")
  test("true", "(<= 1 1)")
  test("true", "(>= 1 1)")
  test("6", "(+ 1 2 3)")

  // Method
  test("1", "(. (tuple 1) 0)")
  test("2", "(. (tuple 1 2) 1)")
  test("1", "(. (new a 1) a)")
  test("2", "(. (new a 1 b 2) b)")
  test("1", '((fn a (. a 0)) (tuple 1))')
  test("1", '((fn a (. a b)) (new b 1))')

  // Lambda
  test("true", "((fn true))")
  test("1", "((fn 1))")
  test("1.2", "((fn 1.2))")
  test("hi", '((fn "hi"))')
  test("1", '((fn a a) 1)')
  test("3", '((fn a b (+ a b)) 1 2)')

  // Definition
  test("1", "a", "(let a 1)")
  test("1", "(f)", "(let f (fn 1))")
  test("1", "(f)", "(let f (fn (do (return 1))))")
  test("1", "(f 1)", "(let f (fn a a))")
  test("3", "(f 1 2)", "(let f (fn a b (+ a b)))")
  test("{1}", "(s 1)", "(struct s a int)")
  test("{1 true}", "(s 1 true)", "(struct s a int b bool)")
  test("1", "(. (s 1) a)", "(struct s a int)")
  test("false", "(. (s 1 false) b)", "(struct s a int b bool)")
  test("1", "((fn b (. b a)) (s 1))", "(struct s a int)")

  // Throw / Catch
  test("error: a", "(f)", '(let f (fn (do (throw "a"))))')
  test("a", '(catch (f) (fn x "b"))', '(let f (fn "a"))')
  test("c", '(catch (f) (fn x "c"))', '(let f (fn (do (throw "a") (return "b"))))')
  test("a", '(catch (f) (fn x (. x message)))', '(let f (fn (do (throw "a") (return "b"))))')

  // Statement
  test("1", "(iif true 1 2)")
  test("2", "(iif false 1 2)")
  test("2", "(iif false 1 true 2 3)")
  test("3", "(iif false 1 false 2 3)")
  test("1", "((fn (do (if true (return 1)) (return 2))))")
  test("2", "((fn (do (if false (return 1)) (return 2))))")
  test("2", "((fn (do (if false (return 1) (return 2)))))")
  test("2", "((fn (do (if false (return 1) true (return 2)) (return 3))))")
  test("6", "a", "(let a 0)(for b 4 (+= a b))")
  test("5", "a", "(let a 0)(for b 2 4 (+= a b))")
  test("9", "a", "(let a 0)(for b 1 6 2 (+= a b))")
  test("6", "a", "(let a 0)(each b (vec 1 2 3) (+= a b))")
  test("6", "a", "(let a 0)(while (< a 6) (+= a 1))")
  test("1", "a", "(let a 0)(for b 3 (do (+= a 1) break))")
  test("0", "a", "(let a 0)(for b 3 (do continue (+= a 1)))")

  // Generics
  test('1', '(iif (f true) (f 1) (f 2))', '(let f (fn a a))')

  // IO
  test("hi2", '((. io put) "hi")')
}

const main = () => {
  testType()
  const fs = require("fs")
  const {execSync} = require("child_process")
  const runtime = fs.readFileSync("runtime.go")
  const cache = fs.existsSync("/tmp/moa_test_cache.json") ? require("/tmp/moa_test_cache.json") : {}
  try {
    const runGo = x => {
      const body = !x.fails ? `fmt.Print(${x.exp})` : `ret, err := ${x.exp}\nif err != nil { fmt.Print("error: " + err.Error()) } else { fmt.Print(ret) }`
      const go = `${runtime}\n${x.def}\nfunc main() { ${x.stmt}\n ${body} }\n`
      if (go in cache) {
        return cache[go]
      }
      fs.writeFileSync("/tmp/moa_test_exp.go", go)
      try {
        return cache[go] = execSync("go run /tmp/moa_test_exp.go").toString()
      } catch (e) {
        return `error: ${e}`
      }
    }
    testMain(runGo)
  } catch (e) {
    console.error(e.stack)
    return 1
  } finally {
    fs.writeFileSync("/tmp/moa_test_cache.json", JSON.stringify(cache, null, 2))
  }
}

console.clear()
process.exit(main())

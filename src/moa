#!node --no-warnings
"use strict"

// - [x] display filename, lineno and column with uncatched error message
// - [ ] io.serve
// - [ ] io.fetch
// - [ ] io.db
// - [ ] moa test
// - [ ] moa repl through process inter-process communication

const log = x => { console.dir(x, {depth: null}); return x }
const range = n => [...new Array(n)].map((_, i) => i)

const newtoken = (s, filename, lineno=0, column=0) => (m => m ? ({code: m[1], mark: m[2], filename, lineno, column}) : ({code: s, filename, lineno, column}))(s.match(/^([A-Za-z_].*)([?*])$/))

const sugar = (program, filename="") => {
  function* tokenize() {
    let pos = 0
    let lineno = 1
    let column = 0
    let indent = 0
    for (const code of program.split(/([A-Za-z_][A-Za-z0-9_]*[?*]?|-?0x[A-Fa-f0-9]+|-?[0-9]+(?:(?:\.[0-9]+)|(?:e[0-9]+))?|""".*?"""|"[^"]*?"|```.*?```|`[^`]*?`|[ \r\n\t]+|[()\[\]{};]|#[^\n]*)/)) {
      if (/^[ \r\n\t#;]/.test(code) || code === "") {
        lineno += code.split(/\n|;/).length - 1
        if (code.includes("\n")) {
          indent = code.split(/\n/).at(-1).length
        }
      } else {
        const op = /^[+\-*/%|&<>=!]+$/.test(code) && code !== "=>"
        const lc = pos > 0 ? program[pos - 1] : ''
        const rc = program[pos + code.length]
        const dot = code === "." && lc !== " " && rc !== " "
        const op2 = op && lc === " " && rc === " "
        const op1 = op && !op2
        const call = code === "(" && /[A-Za-z0-9_\]]/.test(lc)
        const index = code === "[" && /[A-Za-z0-9_\]]/.test(lc)
        yield {code, lineno, op, op1, op2, dot, call, index, indent, filename, lineno, column}
      }
      pos += code.length
      column = code.includes("\n") ? code.split(/\n/).at(-1).length : column + code.length
    }
  }
  const compose = tokens => {
    let pos = 0
    const until = (f, g=bottom) => {
      const a = []
      while (pos < tokens.length && f(tokens[pos])) {
        a.push(g())
      }
      return a
    }
    const faketoken = (s, t) => newtoken(s, filename, t.lineno, t.column)
    const isexp = x => !Array.isArray(x) || x[0].code !== "do"
    const untilby = by => (t => (pos++, t))(until(t => t.code !== by))
    const bottom = () => {
      const totoken = o => Array.isArray(o) ? totoken(o[0]) : o
      const comma = a => pos >= tokens.length ? a :
        tokens[pos].code === "," ? (pos++, comma(a.concat([tokens[pos++]]))) : a
      const addreturn = x => isexp(x) ? x : [...x.slice(0, -1), [faketoken("return", totoken(x)), x.at(-1)]]
      const block = t => {
        if (t.lineno === tokens[pos].lineno) {
          return line()
        } else {
          const a = until(u => u.indent > t.indent, line)
          return a.length === 1 ? a[0] : [faketoken("do", t), ...a]
        }
      }
      const link = t =>
        pos >= tokens.length ? t :
        tokens[pos].code === ","  ? link(comma([t])) :
        tokens[pos].code === "=>" ? (pos++, link([faketoken("fn", tokens[pos-1]), ...(Array.isArray(t) ? t : [t]), addreturn(block(tokens[pos-1]))])) :
        tokens[pos].call          ? (pos++, link([t].concat(untilby(")")))) :
        tokens[pos].dot           ? link([tokens[pos++], t, tokens[pos++]]) :
        tokens[pos].op2           ? link([tokens[pos++], t, bottom()]) :
        t
      const t = tokens[pos++]
      return t.code === ":"  ? block(t) :
             t.op1           ? link([t, bottom()]) :
             link(t)
    }
    const line = () => {
      const lineno = tokens[pos].lineno
      const a = until(t => t.lineno === lineno)
      return a.length === 1 ? a[0] : a
    }
    const top = () => {
      const a = until(_ => true, line)
      return a.length === 1 ? a[0] : a
    }
    return top()
  }
  const normalize = o => Array.isArray(o) ? o.map(normalize) : newtoken(o.code, o.filename, o.lineno, o.column)
  return normalize(compose([...tokenize()]))
}

const parse = (program, filename="") => {
  function* tokenize() {
    let lineno = 1
    let column = 0
    for (const code of program.split(/([()]|[^\n ()]+)/)) {
      if (code.trim()) {
        yield newtoken(code, filename, lineno, column)
        column += code.length
      } else if (/^[ \r\n\t#;]/.test(code) || code === "") {
        lineno += code.split(/\n|;/).length - 1
        if (code.includes("\n")) {
          column = code.split(/\n/).at(-1).length
        }
      }
    }
  }
  const compose = ([t, ...ts], acc=[]) =>
    !t ? acc :
    t.code === ")" ? [acc, compose([ts])] :
    t.code === "(" ? (([x, rest]) => compose(rest, acc.concat([x])))(compose(ts)) :
    compose(ts, acc.concat(t))
  return compose([...tokenize()])
}

class TypeError extends Error { }

const infer = root => {
  let varId = 0
  const newtype = (name, types=[]) => ({name, types})
  const newvar = () => ({...newtype(varId++), var: true})
  const newfn = (types, names, ret) => ({...newtype("fn", types), names, ret})
  const newstruct = types => ({...newfn(types), struct: true})
  const newtuple = types => newtype("tuple", types)
  const newnew = fields => ({...newtype("new", fields.map(a => a.type)), fields})
  const newvec = t => newtype("vec", [t])
  const newset = t => newtype("set", [t])
  const newmap = (k, v) => newtype("map", [k, v])
  const newvargs = vargs => ({...newtype("__varg"), vargs})

  const fails = t => ({...t, fails: true})
  const marks = (t, mark) => mark.includes("*") ? ({...newvec(t), mark}) : ({...t, mark})
  const property = (t, name) => (t.props ||= {}, t.props[name] = newvar())

  const prune = x => x.instance ? x.instance = prune(x.instance) : x
  const tvoid = newtype("struct{}")
  const tbool = newtype("bool")
  const tint = newtype("int")
  const tfloat = newtype("float64")
  const tstring = newtype("string")
  const terror = newtype("error")
  const tio = newtype("io")
  const tv1 = newvar()
  const env = {
    "!": newfn([tbool, tbool]),
    "return": newfn([tv1, tv1]),
    "if": newfn([newvargs([tbool, tv1]), marks(tv1, "?"), tvoid]),
    "iif": newfn([newvargs([tbool, tv1]), tv1, tv1]),
    "throw": fails(newfn([tv1, fails(newvar())])),
    "catch": newfn([tv1, newfn([terror, tv1]), tv1]),
    "while": newfn([tbool, tv1, tvoid]),
    "bool": tbool,
    "int": tint,
    "float": tfloat,
    "string": tstring,
    "continue": tvoid,
    "break": tvoid,
    "io": tio,
  }

  const method = (t, field) =>
    t.var ? property(t, field) :
    t.name === "tuple" && field < t.types.length ? t.types[field] :
    t.name === "error" && field === "message" ? tstring :
    t.name === "io" && field === "put" ? newfn([tv1, tint]) :
    t.fields?.find(f => f.code === field).type ||
    (() => { throw new TypeError(`No '${field}' in '${t.name}${t.types.length ? `[${t.types}]` : ""}' type`) })()
  const unify = (a, b) => {
    a = prune(a)
    b = prune(b)
    if (a === b) {
      // nothing
    } else if (a.var) {
      a.instance = b
      if (a.props) {
        if (b.var) {
          b.props = {...(b.props||={}), ...a.props}
        } else {
          Object.keys(a.props).map(name => unify(a.props[name], method(b, name)))
        }
      }
    } else if (b.var) {
      unify(b, a)
    } else {
      if (a.name !== b.name) {
        throw new TypeError(`Type name ${a.name} != ${b.name}`)
      }
      if (a.types.length !== b.types.length) {
        throw new TypeError(`Type args ${a.types} != ${b.types}`)
      }
      a.types.map((x, i) => unify(x, b.types[i]))
    }
  }
  const safeUnify = (a, b) => {
    try {
      unify(a, b)
      return true
    } catch (e) {
      if (e instanceof TypeError) {
        return false
      } else {
        throw e
      }
    }
  }
  const apply = (f, args) => {
    if (f.var) {
      return (f.instance = newfn([...args, newvar()])).types.at(-1)
    }
    let i = 0
    for (const fa of f.types.slice(0, -1)) {
      if (fa.vargs) {
        while (args[i]) {
          let k = i
          if (!fa.vargs.every(t => args[i] && safeUnify(t, args[i++]))) {
            i = k
            break
          }
        }
      } else if (fa.mark?.includes("*")) {
        while (args[i]) {
          if (!safeUnify(fa.types[0], args[i++])) {
            i--
            break
          }
        }
      } else if (fa.mark?.includes("?")) {
        args[i] && !safeUnify(fa, args[i++]) && i--
      } else {
        unify(fa, args[i++])
      }
    }
    if (i !== args.length) {
      throw new TypeError(`Calling vargs ${JSON.stringify(f.args)} != ${JSON.stringify(args)}`)
    }
    return f.types.at(-1)
  }
  const fresh = (type, nonGeneric) => {
    const d = {}
    const rec = t => {
      const u = prune(t)
      return u.var ?
        (nonGeneric.includes(u.name) ? u : d[u.name] ||= newvar()) :
        (v => (type.generics.push(v.types), v))({...u, types: u.types.map(rec)})
    }
    type.generics ||= []
    return rec(type)
  }
  const isFail = a => Array.isArray(a) ? a[0].code === "throw" || a.some(isFail) : false
  const returnType = a => Array.isArray(a) ? (a.find(x => x[0]?.code === "return")?.[1]?.type || a.reduce((acc, x) => acc || returnType(x), null)) : tvoid
  const infWith = (top, env, nonGeneric) => {
    const inf = node => node.type ||= _inf(node)
    const _inf = node => {
      if (Array.isArray(node)) {
        const head = node[0]
        const tail = node.slice(1)
        if (Array.isArray(head)) {
          return apply(inf(head), tail.map(inf))
        } else {
          const s = head.code
          if (s === "do") {
            tail.map(inf)
            const ret = returnType(tail)
            return isFail(tail) ? fails(ret) : ret
          } else if (s === "struct") {
            const [t, generics, ...ts] = tail
            const gargs = generics.map((t, i) => [t.code, t.type = newvar()])
            const args = range(ts.length / 2).map(i => (ts[i*2].type = infWith(ts[i*2+1], {...env, ...Object.fromEntries(gargs)}, nonGeneric.concat(gargs.map(a => a[1].name))), ts[i*2]))
            return env[t.code] = newstruct(args.map(a => a.type).concat(newnew(args)))
          } else if (s === "fn") {
            const targs = tail.slice(0, -1).map(_ => newvar())
            const args = tail.slice(0, -1).map((t, i) => [t.code, t.type = marks(targs[i], t.mark || "")])
            const body = infWith(tail.at(-1), {...env, ...Object.fromEntries(args)}, nonGeneric.concat(targs.map(t => t.name)))
            return newfn([...args.map(a => a[1]), body], tail.slice(0, -1), tail.at(-1))
          } else if (s === "for") {
            tail[0].type = tint
            tail.slice(1, 1).map(node => unify(tint, inf(node)))
            infWith(tail.at(-1), {...env, ...{[tail[0].code]: tint}}, nonGeneric)
            return tvoid
          } else if (s === "each") {
            tail[0].type = newvar()
            tail.slice(1, -1).map(inf)
            infWith(tail.at(-1), {...env, ...{[tail[0].code]: tail[0].type}}, nonGeneric)
            return tvoid
          } else if (s === "map") {
            const keys = range(tail.length / 2).map(i => inf(tail[i*2]))
            const values = range(tail.length / 2).map(i => inf(tail[i*2+1]))
            return newmap(keys[0], values[0])
          } else if ("+-*/%^=<>!".includes(s[0])) {
            same(tail)
            return "== != < > >= <=".split(" ").includes(s) ? tbool : tail[0].type
          } else if (s === ".") {
            const target = inf(tail[0])
            if (target.name === "tuple") {
              return target.types[tail[1].code]
            } else {
              tail.slice(2).map(inf)
              return method(target, tail[1].code)
            }
          } else if (s === "let") {
            return env[tail[0].code] = inf(tail[1])
          } else if (s === "tuple") {
            return newtuple(tail.map(inf))
          } else if (s === "new") {
            return newnew(range(tail.length / 2).map(i => (tail[i*2].type = inf(tail[i*2+1]), tail[i*2])))
          } else if (s === "vec") {
            return newvec(same(tail))
          } else if (s === "set") {
            return newset(same(tail))
          } else if (s === "||" || s === "&&") {
            return unify(tbool, same(tail))
          } else {
            const argv = tail.map(inf)
            const key = safeJson({code: head.code, argv})
            const ret = apply(inf(head), argv)
            const cache = env.cache ||= {}
            if (key in cache) {
              unify(ret, cache[key])
            } else {
              cache[key] = ret
            }
            return ret
          }
        }
      } else {
        const s = node.code
        return /^[0-9]+\./.test(s)      ? tfloat :
          /^[0-9]+/.test(s)             ? tint :
          s === "true" || s === "false" ? tbool :
          s.startsWith('"')             ? tstring :
          s in env ? fresh(env[s], nonGeneric) :
          (() => { throw new Error(`Type literal '${s}'`) })()
      }
    }
    const same = a => (([x, ...ts]) => (ts.map(t => unify(t, x)), x))(a.map(inf))
    return inf(top)
  }
  const safeJson = o => {
    const seen = new Set()
    return JSON.stringify(o, (key, value) =>
      typeof value === "object" && value !== null ?
      (seen.has(value) ? seen.size : (seen.add(value), value)) :
      value)
  }

  const copy = t => ({...prune(t), mark: t.mark})
  const fix = node => {
    if (Array.isArray(node)) {
      node.map(fix)
    }
    if (node.type) {
      node.type = copy(node.type)
      node.type.types = node.type.types.map(copy)
      if (node.type.generics) {
        const d = {}
        for (const a of node.type.generics) {
          const t = a.map(prune)
          d[safeJson(t)] ||= t
        }
        node.type.generics = Object.values(d)
      }
    }
  }

  root.map(node => infWith(node, env, [tv1.name]))
  root.map(fix)
  return root
}

const generate = root => {
  let id = 0
  const newid = () => `__${id++}`
  const defs = []
  const lines = []
  const genreturn = x => {
    const ret = generate([x])
    return x[0]?.code === "do" ? ret.body + "\n" + ret.exp : `${ret.body}\nreturn ${ret.exp}`
  }
  const genop = (op, xs) => xs.length === 1 ? `${op} ${gen(xs[0])}` : genop2(op, xs)
  const genop2 = (op, xs) => xs.length === 1 ? gen(xs[0]) : `${gen(xs[0])} ${op} ${genop2(op, xs.slice(1))}`
  const gentype = t => t.types.length === 0 ? (t.var ? "__" : "") + t.name :
    t.name === "tuple" ? `__${t.name}${t.types.length}[${t.types.map(gentype)}]` :
    t.name === "new" ? genstruct([], t) :
    `${t.name}[${t.types.map(gentype)}]`
  const genstruct = (a, t) => (a.length ? `[${a.map(u => gentype(u.type) + " any")}] ` : "") + `struct { ${t.fields.map(f => `${f.code} ${gentype(f.type)}`).join("\n")} }`
  const genfunc = (t, name="") => `func ${name}(${t.names.map(a => `${a.code} ${gentype(a.type)}`)}) (__ret ${gentype(t.ret.type)}${t.ret.type.fails ? ", __err error" : ""})`
  const genassign = (id, x) => x.type.fails ? `${id}, __err = ${genexp(x)}; if __err != nil { return }` : `${id} = ${genexp(x)}`
  const geniif = (id , a) => a.length === 1 ? `{ ${genassign(id, a[0])} }` :
    `if ${gen(a[0])} { ${genassign(id, a[1])} } else ${geniif(id, a.slice(2))}`
  const genif = a =>
    a.length === 0 ? "" :
    a.length === 1 ? ` else { ${gen(a[0])} }` :
    ` else if ${gen(a[0])} { ${gen(a[1])} } ${genif(a.slice(2))}`
  const genfor = ([a, b, c, d, e]) =>
    e ? `for ${a} := ${b}; ${a} < ${c}; ${a} += ${d} { ${e} }` :
    d ? `for ${a} := ${b}; ${a} < ${c}; ${a}++ { ${d} }` :
    c ? `for ${a} := 0; ${a} < ${b}; ${a}++ { ${c} }` :
    (() => {throw new Error(`genfor ${a}, ${b}, ${c}, ${d}, ${e}`)})()
  const genlet = (name, body) => {
    if (body[0]?.code === "fn" && body.type.types.find(x => x.var) && body.type.generics.length) {
      for (const a of body.type.generics) {
        const x = structuredClone(body)
        x.type = {...x.type, types: a}
        x.slice(1, -1).map((arg, i) => arg.type = a[i])
        x.type.names.map((arg, i) => arg.type = a[i])
        x.type.ret.type = a.at(-1)
        lines.push(`${name}__${a.map(gentype).join("__")} := ${gen(x)}`)
      }
    } else {
      lines.push(`${name} := ${gen(body)}`)
    }
    return ""
  }
  const genhead = x => x.type.name === "fn" && x.type.names?.find(y => y.type.var) && x.type.generics?.length ?
    `${gen(x)}__${x.type.types.map(gentype).join("__")}` : gen(x)
  const gen = x => Array.isArray(x) && x[0].type?.types.at(-1).fails ? ((ret, a) => (
      a.map(([id, y]) => lines.push(`${id} = ${c}`)),
      lines.push(`${ret}, __err := ${genhead(x[0])}(${a.map(z => z[0])})`),
      ret
    ))(newid(), x.slice(1).map(y => [newid(), y])) :
    genexp(x)
  const errinfo = x => Array.isArray(x) ? errinfo(x[0]) : [JSON.stringify(x.filename), x.lineno, x.column]
  const genexp = x => !Array.isArray(x) ? x.code :
    x[0].code === "do"     ? x.slice(1).map(gen).join("\n") :
    x[0].code === "for"    ? (lines.push(genfor(x.slice(1).map(gen))), "") :
    x[0].code === "each"   ? (lines.push(`for _, ${x[1].code} := range ${gen(x[2])} { ${gen(x[3])} }`), "") :
    x[0].code === "while"  ? (lines.push(`for ${gen(x[1])} { ${gen(x[2])} }`), "") :
    x[0].code === "let"    ? genlet(x[1].code, x[2]) :
    x[0].code === "return" ? `__ret = ${gen(x[1])}; return` :
    x[0].code === "throw"  ? `__err = MoaError{${gen(x[1])}, ${errinfo(x[1])}}; return` :
    x[0].code === "catch"  ? !x[1].type.fails ? gen(x[1]) : (exp => (lines.push("__catch_err := __err; __err = nil"), `__catch[${gentype(x[1].type)}](${exp}, __catch_err, ${gen(x[2])})`))(gen(x[1])) :
    x[0].code === "if"     ? `if ${gen(x[1])} { ${gen(x[2])} }${genif(x.slice(3))}` :
    x[0].code === "iif"    ? (id => (lines.push(`var ${id} ${gentype(x[2].type)}; ${geniif(id, x.slice(1))}`), id))(newid()) :
    x[0].code === "struct" ? (defs.push(`type ${x[1].code} ${genstruct(x[2], x.type.types.at(-1))}`), "") :
    x[0].code === "fn"     ? `${genfunc(x.type)} { ${genreturn(x.at(-1))} }` :
    x[0].code === "tuple"  ? `__tuple${x.length - 1}[${x.slice(1).map(node => gentype(node.type))}]{ ${x.slice(1).map(gen)} }` :
    x[0].code === "new"    ? `${genstruct([], x.type)}{${range((x.length-1)/2).map(i => gen(x[i*2+2]))}}` :
    x[0].code === "vec"    ? `[]${gentype(x[1].type)}{ ${x.slice(1).map(gen)} }` :
    x[0].code === "map"    ? `map[${gentype(x[1].type)}]${gentype(x[2].type)}{ ${range((x.length-1)/2).map(i => `${gen(x[i*2+1])}: ${gen(x[i*2+2])}`)} }` :
    x[0].code === "set"    ? `map[${gentype(x[1].type)}]struct{}{ ${x.slice(1).map(n => `${gen(n)}: struct{}{}`)} }` :
    x[0].code === "!"      ? `${x[0].code}${gen(x[1])}` :
    x[0].type?.struct      ? gen(x[0]) + (x[0].type.types.at(-1).types.find(t => t.var) ? `[${x[0].type.types.slice(0, -1).map(gentype)}]` : "")+ "{" + x.slice(1).map(gen).join(", ") + "}" :
    x[0].code === "." && x[1]?.type?.name === "tuple" ? `${gen(x[1])}.v${x[2].code}` :
    x[0].code === "." && x[1]?.type?.name === "error" && x[2].code === "message" ? `${gen(x[1])}.Error()` :
    /[+\-*/%^<>!=|&.]/.test(x[0].code) ? genop(x[0].code, x.slice(1)) :
    genhead(x[0]) + "(" + x.slice(1).map(gen).join(", ") + ")"
  const exps = root.map(gen)
  return {
    def: defs.join("\n"),
    body: lines.concat(exps.slice(0, -1)).join("\n"),
    exp: exps.at(-1)
  }
}

const compile = (code, filename) => generate(infer(parse(code, filename)))

const execGo = (cmd) => {
  const fs = require("fs")
  const {execSync} = require("child_process")
  const files = process.argv.length === 3 ? fs.globSync("**/*.moa") : process.argv.slice(3)
  const runtime = fs.readFileSync(__dirname + "/runtime.go", "utf-8")
  const x = compile(files.map(path => fs.readFileSync(path, "utf-8")).join("\n"))
  const go = `${runtime}\n${x.def}\nfunc main() {
  var __err error
  defer func() {
    if __err != nil {
      panic(__err)
    }
  }()
  ${x.body}
  ${x.exp}
}`
  fs.writeFileSync("/tmp/a.go", go)
  execSync(`go ${cmd} /tmp/a.go`, {stdio: "inherit"})
}

if (process.argv[2] === "selftest") {
  process.exit(require("./test.js").test({sugar, parse, infer, compile, TypeError}))
} else if (process.argv[2] === "version") {
  console.log("moa version 0.0.1")
} else if (process.argv[2] === "build") {
  execGo("build")
} else if (process.argv[2] === "run") {
  execGo("run")
} else {
  console.log(`Moa is a programming language

Usage: moa <command> [...arguments]

Commands:
  moa build [...files]     compile to an executable file
  moa run   [...files]     compile and run
  moa repl  [...files]     start a shell
  moa test  [...files]     run tests
  moa version              display Moa version`)
}

#!node
"use strict"

// - [x] bool literal
// - [x] int literal
// - [x] float literal
// - [x] string literal
// - [x] fn
// - [x] tuple
// - [x] new
// - [x] vec
// - [x] set
// - [x] map
// - [x] operators
// - [x] do
// - [x] let
// - [x] def
// - [x] struct
// - [x] throw
// - [x] catch
// - [ ] iif
// - [ ] if
// - [ ] for
// - [ ] each
// - [ ] while
// - [ ] log
// - [ ] io

const log = x => { console.dir(x, {depth: null}); return x }
const show = x => Array.isArray(x) ? `(${x.map(show).join(" ")})` : x.code
const range = n => [...new Array(n)].map((_, i) => i)

const tokenize = code => code.split(/([()]|[^ ()]+)/).filter(s => s.trim()).map(s => ({code: s}))

const parse = ([t, ...ts], acc=[]) =>
  !t ? acc :
  t.code === ")" ? [acc, ts] :
  t.code === "(" ? (([x, rest]) => parse(rest, acc.concat([x])))(parse(ts)) :
  parse(ts, acc.concat(t))

const infer = root => {
  let varId = 0
  const newvar = () => newtype(varId++)
  const newtype = (name, args=[]) => ({name, args})
  const newfn = (args, names, ret) => ({...newtype("fn", args), names, ret})
  const newstruct = args => ({...newfn(args), struct: true})
  const newtuple = args => newtype("tuple", args)
  const newnew = fields => ({...newtype("new", fields.map(a => a.type)), fields})
  const newvec = t => newtype("vec", [t])
  const newset = t => newtype("set", [t])
  const newmap = (k, v) => newtype("map", [k, v])

  const fails = t => ({...t, fails: true})
  const property = (t, name) => (t.props ||= {}, t.props[name] = newvar())

  const prune = x => x.instance ? x.instance = prune(x.instance) : x
  const tv1 = newvar()
  const tvoid = newtype("struct{}")
  const tbool = newtype("bool")
  const tint = newtype("int")
  const tfloat = newtype("float64")
  const tstring = newtype("string")
  const terror = newtype("error")
  const method = (t, field) => {
    if (typeof t.name === "number") {
      return property(t, field)
    } else if (t.name === "tuple" && field < t.args.length) {
      return t.args[field]
    } else if (t.name === "new" && t.fields.find(f => f.code === field)) {
      return t.fields.find(f => f.code === field).type
    } else if (t.fields) {
      return t.args[t.fields.indexOf(field)]
    } else if (t.name === "error" && field === "message") {
      return tstring
    } else {
      throw new Error(`No ${field} in ${t.name}${t.args.length ? `[${t.args}]` : ''}`)
    }
  }
  const unify = (a, b) => {
    a = prune(a)
    b = prune(b)
    if (typeof a.name === "number") {
      a.instance = b
      if (a.props) {
        if (b.name === "number") {
          b.props = {...(b.props||={}), ...a.props}
        } else {
          for (const name in a.props) {
            unify(a.props[name], method(b, name))
          }
        }
      }
    } else if (typeof b.name === "number") {
      unify(b, a)
    } else {
      if (a.name !== b.name) {
        throw new Error(`Type name ${a.name} != ${b.name}`)
      }
      if (a.args.length !== b.args.length) {
        throw new Error(`Type args ${a.args} != ${b.args}`)
      }
      a.args.map((x, i) => unify(x, b.args[i]))
    }
  }
  const apply = (f, args) => {
    if ((f.args.length - 1) !== args.length) {
      throw new Error(`Calling ${f.args.length - 1} != ${args.length}`)
    }
    args.map((x, i) => unify(x, f.args[i]))
    return f.args.at(-1)
  }
  const iscmp = s => "== != < > >= <=".split(" ").includes(s)
  const islogical = s => s === "||" || s === "&&"
  const isFail = a => Array.isArray(a) ? a[0].code === "throw" || a.some(isFail) : false
  const inferWith = (top, local, ngs) => {
    const _inf = node => {
      if (Array.isArray(node)) {
        const head = node[0]
        const tail = node.slice(1)
        if (Array.isArray(head)) {
          return apply(inf(head), tail.map(inf))
        } else {
          const s = head.code
          if (s === "do") {
            const ret = tail.find(x => x[0]?.code === "return")
            tail.map(inf)
            const t = ret ? ret[1].type : tvoid
            return isFail(tail) ? fails(t) : t
          } else if (s === "let") {
            return local[tail[0].code] = inf(tail[1])
          } else if (s === "def") {
            const [t, ...ts] = tail
            const args = ts.slice(0, -1).map(t => [t.code, t.type = newvar()])
            const body = inferWith(ts.at(-1), {...local, ...Object.fromEntries(args)}, ngs)
            return local[t.code] = newfn([...args.map(a => a[1]), body], ts.slice(0, -1), ts.at(-1))
          } else if (s === "struct") {
            const [t, ...ts] = tail
            const args = range(ts.length / 2).map(i => (ts[i*2].type = inf(ts[i*2+1]), ts[i*2]))
            return local[t.code] = newstruct(args.map(a => a.type).concat(newnew(args)))
          } else if (s === "fn") {
            const args = tail.slice(0, -1).map(t => [t.code, t.type = newvar()])
            const body = inferWith(tail.at(-1), {...local, ...Object.fromEntries(args)}, ngs)
            return newfn([...args.map(a => a[1]), body], tail.slice(0, -1), tail.at(-1))
          } else if (s === "tuple") {
            return newtuple(tail.map(inf))
          } else if (s === "new") {
            return newnew(range(tail.length / 2).map(i => (tail[i*2].type = inf(tail[i*2+1]), tail[i*2])))
          } else if (s === "vec") {
            return newvec(same(tail))
          } else if (s === "set") {
            return newset(same(tail))
          } else if (s === "map") {
            const keys = range(tail.length / 2).map(i => inf(tail[i*2]))
            const values = range(tail.length / 2).map(i => inf(tail[i*2+1]))
            return newmap(keys[0], values[0])
          } else if (islogical(s)) {
            return same(tail)
          } else if ("+-*/%^=".includes(s) || iscmp(s)) {
            return iscmp(s) ? tbool : same(tail)
          } else if (s === ".") {
            const target = inf(tail[0])
            if (target.name === "tuple") {
              return target.args[tail[0].code]
            } else {
              const field = tail[1].code
              const args = tail.slice(2).map(inf)
              return method(target, field)
            }
          } else {
            return apply(inf(head), tail.map(inf))
          }
        }
      } else {
        const s = node.code
        const t = /^[0-9]+\./.test(s)   ? tfloat :
          /^[0-9]+/.test(s)             ? tint :
          s === "true" || s === "false" ? tbool :
          s.startsWith('"')             ? tstring :
          local[s] || env[s]
        if (!t) {
          throw new Error(`Type literal '${s}'`)
        }
        return t
      }
    }
    const inf = node => node.type ||= _inf(node)
    const same = a => (([x, ...ts]) => (ts.map(t => unify(t, x)), x))(a.map(inf))
    return inf(top)
  }
  const fix = node => {
    if (Array.isArray(node)) {
      node.map(fix)
    }
    if (node.type) {
      node.type = prune(node.type)
      node.type.args = node.type.args.map(prune)
    }
  }

  const env = {
    "!": newfn([tbool, tbool]),
    "return": newfn([tv1, tv1]),
    "throw": fails(newfn([tv1, fails(newvar())])),
    "catch": newfn([tv1, newfn([terror, tv1]), tv1]),
    "bool": tbool,
    "int": tint,
    "float": tfloat,
    "string": tstring,
  }
  root.map(node => inferWith(node, env, []))
  root.map(fix)
  return root
}

const generate = root => {
  let id = 0
  const newId = () => `__${id++}`
  const defs = []
  const lines = []
  const genreturn = x => x[0]?.code === "do" ? gen(x) : `return ${gen(x)}`
  const genop = (op, xs) => xs.length === 1 ? `${op} ${gen(xs[0])}` : genop2(op, xs)
  const genop2 = (op, xs) => xs.length === 1 ? gen(xs[0]) : `${gen(xs[0])} ${op} ${genop2(op, xs.slice(1))}`
  const gentype = t => t.args.length === 0 ? t.name :
    t.name === "tuple" ? `__${t.name}${t.args.length}[${t.args.map(gentype)}]` :
    t.name === "new" ? genstruct(t) :
    `${t.name}[${t.args.map(gentype)}]`
  const genstruct = t => `struct { ${t.fields.map(f => `${f.code} ${gentype(f.type)}`).join("\n")} }`
  const genfunc = (t, name="") => `func ${name}(${t.names.map(a => `${a.code} ${gentype(a.type)}`)}) (__ret ${gentype(t.ret.type)}${t.ret.type.fails ? ', __err error' : ''})`
  const gen = x => !Array.isArray(x) ? x.code :
    x[0].code === "do"     ? x.slice(1).map(gen).join("\n") :
    x[0].code === "let"    ? `${x[1].code} := ${gen(x[2])}` :
    x[0].code === "return" ? `__ret = ${gen(x[1])}; return` :
    x[0].code === "throw"  ? `__err = errors.New(${gen(x[1])}); return` :
    x[0].code === "catch"  ? ((id1, id2) => (lines.push(`${id1}, ${id2} := ${gen(x[1])}; if ${id2} != nil { ${id1} = ${gen(x[2])}(${id2}) }`), id1))(newId(), newId()) :
    x[0].code === "def"    ? (defs.push(`${genfunc(x.type, x[1].code)} { ${genreturn(x.at(-1))} }`), "") :
    x[0].code === "struct" ? (defs.push(`type ${x[1].code} ${genstruct(x.type.args.at(-1))}`), "") :
    x[0].code === "fn"     ? `${genfunc(x.type)} { ${genreturn(x.at(-1))} }` :
    x[0].code === "tuple"  ? `__tuple${x.length - 1}[${x.slice(1).map(node => gentype(node.type))}]{ ${x.slice(1).map(gen)} }` :
    x[0].code === "new"    ? `${genstruct(x.type)}{${range((x.length-1)/2).map(i => gen(x[i*2+2]))}}` :
    x[0].code === "vec"    ? `[]${gentype(x[1].type)}{ ${x.slice(1).map(gen)} }` :
    x[0].code === "map"    ? `map[${gentype(x[1].type)}]${gentype(x[2].type)}{ ${range((x.length-1)/2).map(i => `${gen(x[i*2+1])}: ${gen(x[i*2+2])}`)} }` :
    x[0].code === "set"    ? `map[${gentype(x[1].type)}]struct{}{ ${x.slice(1).map(n => `${gen(n)}: struct{}{}`)} }` :
    x[0].code === "!"      ? `${x[0].code} ${gen(x[1])}` :
    x[0].type?.struct      ?  gen(x[0]) + "{" + x.slice(1).map(gen).join(", ") + "}" :
    x[0].code === "." && x[1]?.type?.name === "tuple" ? `${gen(x[1])}.v${x[2].code}` :
    x[0].code === "." && x[1]?.type?.name === "error" && x[2].code === "message" ? `${gen(x[1])}.Error()` :
    /[+\-*/%^<>!=|&.]/.test(x[0].code) ? genop(x[0].code, x.slice(1)) :
    gen(x[0]) + "(" + x.slice(1).map(gen).join(", ") + ")"
  const exp = root.map(gen).join("")
  return {
    def: defs.join("\n"),
    stmt: lines.join("\n"),
    exp: exp,
    fails: root.at(-1).type?.fails
  }
}

const compile = code => generate(infer(parse(tokenize(code))))

const testMain = runGo => {
  const test = (expected, exp) => {
    const go = compile(exp)
    const actual = runGo(go)
    if (expected !== actual) {
      throw new Error(`${expected} != ${actual}\n# exp\n${exp}\n# go\n${go.exp}\n${go.stmt}\n${go.def}`)
    }
  }

  // Value
  test("true", "true")
  test("1", "1")
  test("1.2", "1.2")
  test("hi", '"hi"')
  test("{1}", "(tuple 1)")
  test("{1 2}", "(tuple 1 2)")
  test("{1}", "(new a 1)")
  test("{1 2}", "(new a 1 b 2)")
  test("[1]", "(vec 1)")
  test("[1 2]", "(vec 1 2)")
  test("[true]", "(vec true)")
  test("map[1:true]", "(map 1 true)")
  test("map[1:true 2:false]", "(map 1 true 2 false)")
  test("map[1:{}]", "(set 1)")
  test("map[1:{} 2:{}]", "(set 1 2)")

  // Operator
  test("false", "(! true)")
  test("-1", "(- 1)")
  test("-2", "(^ 1)")
  test("3", "(+ 1 2)")
  test("1", "(- 3 2)")
  test("6", "(* 2 3)")
  test("2", "(/ 4 2)")
  test("1", "(% 3 2)")
  test("3", "(^ 1 2)")
  test("true", "(== 1 1)")
  test("false", "(!= 1 1)")
  test("false", "(< 1 1)")
  test("false", "(> 1 1)")
  test("true", "(<= 1 1)")
  test("true", "(>= 1 1)")
  test("6", "(+ 1 2 3)")

  // Method
  test("1", "(. (tuple 1) 0)")
  test("2", "(. (tuple 1 2) 1)")
  test("1", "(. (new a 1) a)")
  test("2", "(. (new a 1 b 2) b)")
  test("1", '((fn a (. a 0)) (tuple 1))')
  test("1", '((fn a (. a b)) (new b 1))')

  // Lambda
  test("true", "((fn true))")
  test("1", "((fn 1))")
  test("1.2", "((fn 1.2))")
  test("hi", '((fn "hi"))')
  test("1", '((fn a a) 1)')
  test("3", '((fn a b (+ a b)) 1 2)')

  // Definition
  test("1", "(def f 1)(f)")
  test("1", "(def f (do (let a 1) (return a)))(f)")
  test("1", "(def f (do (let a 1) (return a) (return 0)))(f)")
  test("1", "(def f a a)(f 1)")
  test("3", "(def f a b (+ a b))(f 1 2)")
  test("{1}", "(struct s a int)(s 1)")
  test("{1 true}", "(struct s a int b bool)(s 1 true)")
  test("1", "(struct s a int)(. (s 1) a)")
  test("false", "(struct s a int b bool)(. (s 1 false) b)")
  test("1", "(struct s a int)((fn b (. b a)) (s 1))")

  // Throw / Catch
  test("error: a", '(def f (do (throw "a")))(f)')
  test("c", '(def f (do (throw "a") (return "b")))(catch (f) (fn x "c"))')
  test("a", '(def f (do (throw "a") (return "b")))(catch (f) (fn x (. x message)))')
}

const main = () => {
  const fs = require("fs")
  const child_process = require("child_process")
  const runtime = fs.readFileSync("runtime.go")
  const safe = (f, g) => { try { return f() } catch(e) { return g(e) } }
  const cache = safe(() => require("/tmp/moa_test_cache.json"), () => ({}))
  try {
    const runGo = x => {
      const body = x.fails ? `ret, err := ${x.exp}\nif err != nil { fmt.Print("error: " + err.Error()) } else { fmt.Print(ret) }` : `fmt.Print(${x.exp})`
      const go = `${runtime}\n${x.def}\nfunc main() { ${x.stmt}\n ${body} }\n`
      if (go in cache) {
        return cache[go]
      }
      fs.writeFileSync("/tmp/moa_test_exp.go", go)
      return cache[go] = safe(() => child_process.execSync("go run /tmp/moa_test_exp.go").toString(), e => `error: ${e}`)
    }
    testMain(runGo)
  } catch (e) {
    console.error(e.stack)
    return 1
  } finally {
    fs.writeFileSync("/tmp/moa_test_cache.json", JSON.stringify(cache, null, 2))
  }
}

console.clear()
process.exit(main())

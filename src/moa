#!node --no-warnings
"use strict"

// - [ ] user definition variadic arguments
// - [ ] user definition generic struct
// - [ ] complex code generation

const log = x => { console.dir(x, {depth: null}); return x }
const range = n => [...new Array(n)].map((_, i) => i)

const tokenize = code => code.split(/([()]|[^\n ()]+)/).filter(s => s.trim()).map(s => ({code: s}))

const parse = ([t, ...ts], acc=[]) =>
  !t ? acc :
  t.code === ")" ? [acc, parse([ts])] :
  t.code === "(" ? (([x, rest]) => parse(rest, acc.concat([x])))(parse(ts)) :
  parse(ts, acc.concat(t))

class TypeError extends Error { }

const infer = root => {
  let varId = 0
  const newtype = (name, types=[]) => ({name, types})
  const newvar = () => ({...newtype(varId++), var: true})
  const newfn = (types, names, ret) => ({...newtype("fn", types), names, ret})
  const newstruct = types => ({...newfn(types), struct: true})
  const newtuple = types => newtype("tuple", types)
  const newnew = fields => ({...newtype("new", fields.map(a => a.type)), fields})
  const newvec = t => newtype("vec", [t])
  const newset = t => newtype("set", [t])
  const newmap = (k, v) => newtype("map", [k, v])
  const newvargs = vargs => ({...newtype("__varg"), vargs})

  const fails = t => ({...t, fails: true})
  const optional = t => ({...t, optional: true})
  const property = (t, name) => (t.props ||= {}, t.props[name] = newvar())

  const prune = x => x.instance ? x.instance = prune(x.instance) : x
  const tvoid = newtype("struct{}")
  const tbool = newtype("bool")
  const tint = newtype("int")
  const tfloat = newtype("float64")
  const tstring = newtype("string")
  const terror = newtype("error")
  const tio = newtype("io")
  const tv1 = newvar()
  const env = {
    "!": newfn([tbool, tbool]),
    "return": newfn([tv1, tv1]),
    "if": newfn([newvargs([tbool, tv1]), optional(tv1), tvoid]),
    "iif": newfn([newvargs([tbool, tv1]), tv1, tv1]),
    "throw": fails(newfn([tv1, fails(newvar())])),
    "catch": newfn([tv1, newfn([terror, tv1]), tv1]),
    "while": newfn([tbool, tv1, tvoid]),
    "bool": tbool,
    "int": tint,
    "float": tfloat,
    "string": tstring,
    "continue": tvoid,
    "break": tvoid,
    "io": tio,
  }

  const method = (t, field) =>
    t.var ? property(t, field) :
    t.name === "tuple" && field < t.types.length ? t.types[field] :
    t.name === "error" && field === "message" ? tstring :
    t.name === "io" && field === "put" ? newfn([tv1, tint]) :
    t.fields?.find(f => f.code === field).type ||
    (() => { throw new TypeError(`No ${field} in ${t.name}${t.types.length ? `[${t.types}]` : ""}`) })()
  const unify = (a, b) => {
    a = prune(a)
    b = prune(b)
    if (a === b) {
      // nothing
    } else if (a.var) {
      a.instance = b
      if (a.props) {
        if (b.var) {
          b.props = {...(b.props||={}), ...a.props}
        } else {
          Object.keys(a.props).map(name => unify(a.props[name], method(b, name)))
        }
      }
    } else if (b.var) {
      unify(b, a)
    } else {
      if (a.name !== b.name) {
        throw new TypeError(`Type name ${a.name} != ${b.name}`)
      }
      if (a.types.length !== b.types.length) {
        throw new TypeError(`Type args ${a.types} != ${b.types}`)
      }
      a.types.map((x, i) => unify(x, b.types[i]))
    }
  }
  const safeUnify = (a, b) => {
    try {
      unify(a, b)
      return true
    } catch (e) {
      if (e instanceof TypeError) {
        return false
      } else {
        throw e
      }
    }
  }
  const apply = (f, args) => {
    if (f.var) {
      return (f.instance = newfn([...args, newvar()])).types.at(-1)
    }
    let i = 0
    for (const fa of f.types.slice(0, -1)) {
      if (fa.name === "__varg") {
        while (args[i]) {
          let k = i
          if (!fa.vargs.every(t => args[i] && safeUnify(t, args[i++]))) {
            i = k
            break
          }
        }
      } else if (fa.optional) {
        args[i] && !safeUnify(fa, args[i++]) && i--
      } else {
        unify(fa, args[i++])
      }
    }
    if (i !== args.length) {
      throw new TypeError(`Calling vargs ${JSON.stringify(f.args)} != ${JSON.stringify(args)}`)
    }
    return f.types.at(-1)
  }
  const fresh = (type, nonGeneric) => {
    const d = {}
    const rec = t => {
      const u = prune(t)
      return u.var ?
        (nonGeneric.includes(u.name) ? u : d[u.name] ||= newvar()) :
        (v => (type.generics.push(v.types), v))({...u, types: u.types.map(rec)})
    }
    type.generics ||= []
    return rec(type)
  }
  const isFail = a => Array.isArray(a) ? a[0].code === "throw" || a.some(isFail) : false
  const returnType = a => Array.isArray(a) ? (a.find(x => x[0]?.code === "return")?.[1]?.type || a.reduce((acc, x) => acc || returnType(x), null)) : tvoid
  const inferWith = (top, env, nonGeneric) => {
    const inf = node => node.type ||= _inf(node)
    const _inf = node => {
      if (Array.isArray(node)) {
        const head = node[0]
        const tail = node.slice(1)
        if (Array.isArray(head)) {
          return apply(inf(head), tail.map(inf))
        } else {
          const s = head.code
          if (s === "do") {
            tail.map(inf)
            const ret = returnType(tail)
            return isFail(tail) ? fails(ret) : ret
          } else if (s === "struct") {
            const [t, ...ts] = tail
            const args = range(ts.length / 2).map(i => (ts[i*2].type = inf(ts[i*2+1]), ts[i*2]))
            return env[t.code] = newstruct(args.map(a => a.type).concat(newnew(args)))
            return t
          } else if (s === "fn") {
            const args = tail.slice(0, -1).map(t => [t.code, t.type = newvar()])
            const body = inferWith(tail.at(-1), {...env, ...Object.fromEntries(args)}, nonGeneric.concat(args.map(a => a[1].name)))
            return newfn([...args.map(a => a[1]), body], tail.slice(0, -1), tail.at(-1))
          } else if (s === "for") {
            tail[0].type = tint
            tail.slice(1, 1).map(node => unify(tint, inf(node)))
            inferWith(tail.at(-1), {...env, ...{[tail[0].code]: tint}}, nonGeneric)
            return tvoid
          } else if (s === "each") {
            tail[0].type = newvar()
            tail.slice(1, -1).map(inf)
            inferWith(tail.at(-1), {...env, ...{[tail[0].code]: tail[0].type}}, nonGeneric)
            return tvoid
          } else if (s === "map") {
            const keys = range(tail.length / 2).map(i => inf(tail[i*2]))
            const values = range(tail.length / 2).map(i => inf(tail[i*2+1]))
            return newmap(keys[0], values[0])
          } else if ("+-*/%^=<>!".includes(s[0])) {
            same(tail)
            return "== != < > >= <=".split(" ").includes(s) ? tbool : tail[0].type
          } else if (s === ".") {
            const target = inf(tail[0])
            if (target.name === "tuple") {
              return target.types[tail[0].code]
            } else {
              tail.slice(2).map(inf)
              return method(target, tail[1].code)
            }
          } else if (s === "let") {
            return env[tail[0].code] = inf(tail[1])
          } else if (s === "tuple") {
            return newtuple(tail.map(inf))
          } else if (s === "new") {
            return newnew(range(tail.length / 2).map(i => (tail[i*2].type = inf(tail[i*2+1]), tail[i*2])))
          } else if (s === "vec") {
            return newvec(same(tail))
          } else if (s === "set") {
            return newset(same(tail))
          } else if (s === "||" || s === "&&") {
            return unify(tbool, same(tail))
          } else {
            const argv = tail.map(inf)
            const key = safeJson({code: head.code, argv})
            const ret = apply(inf(head), argv)
            const cache = env.cache ||= {}
            if (key in cache) {
              unify(ret, cache[key])
            } else {
              cache[key] = ret
            }
            return ret
          }
        }
      } else {
        const s = node.code
        return /^[0-9]+\./.test(s)      ? tfloat :
          /^[0-9]+/.test(s)             ? tint :
          s === "true" || s === "false" ? tbool :
          s.startsWith('"')             ? tstring :
          s in env ? fresh(env[s], nonGeneric) :
          (() => { throw new Error(`Type literal '${s}'`) })()
      }
    }
    const same = a => (([x, ...ts]) => (ts.map(t => unify(t, x)), x))(a.map(inf))
    return inf(top)
  }
  const safeJson = o => {
    const seen = new Set()
    return JSON.stringify(o, (key, value) =>
      typeof value === "object" && value !== null ?
      (seen.has(value) ? seen.size : (seen.add(value), value)) :
      value)
  }

  const fix = node => {
    if (Array.isArray(node)) {
      node.map(fix)
    }
    if (node.type) {
      node.type = prune(node.type)
      node.type.types = node.type.types.map(prune)
      if (node.type.generics) {
        const d = {}
        for (const a of node.type.generics) {
          const t = a.map(prune)
          d[safeJson(t)] ||= t
        }
        node.type.generics = Object.values(d)
      }
    }
  }

  root.map(node => inferWith(node, env, [tv1.name]))
  root.map(fix)
  return root
}

const generate = root => {
  let id = 0
  const newId = () => `__${id++}`
  const defs = []
  const lines = []
  const genreturn = x => {
    const ret = generate([x])
    return x[0]?.code === "do" ? ret.stmt + "\n" + ret.exp : `${ret.stmt}\nreturn ${ret.exp}`
  }
  const genop = (op, xs) => xs.length === 1 ? `${op} ${gen(xs[0])}` : genop2(op, xs)
  const genop2 = (op, xs) => xs.length === 1 ? gen(xs[0]) : `${gen(xs[0])} ${op} ${genop2(op, xs.slice(1))}`
  const gentype = t => t.types.length === 0 ? t.name :
    t.name === "tuple" ? `__${t.name}${t.types.length}[${t.types.map(gentype)}]` :
    t.name === "new" ? genstruct(t) :
    `${t.name}[${t.types.map(gentype)}]`
  const genstruct = t => `struct { ${t.fields.map(f => `${f.code} ${gentype(f.type)}`).join("\n")} }`
  const genfunc = (t, name="") => `func ${name}(${t.names.map(a => `${a.code} ${gentype(a.type)}`)}) (__ret ${gentype(t.ret.type)}${t.ret.type.fails ? ", __err error" : ""})`
  const geniif = (id , a) => a.length === 1 ? `{ ${id} = ${gen(a[0])} }` : `if ${gen(a[0])} { ${id} = ${gen(a[1])} } else ${geniif(id, a.slice(2))}`
  const genif = a =>
    a.length === 0 ? "" :
    a.length === 1 ? ` else { ${gen(a[0])} }` :
    ` else if ${gen(a[0])} { ${gen(a[1])} } ${genif(a.slice(2))}`
  const genfor = ([a, b, c, d, e]) =>
    e ? `for ${a} := ${b}; ${a} < ${c}; ${a} += ${d} { ${e} }` :
    d ? `for ${a} := ${b}; ${a} < ${c}; ${a}++ { ${d} }` :
    c ? `for ${a} := 0; ${a} < ${b}; ${a}++ { ${c} }` :
    (() => {throw new Error(`genfor ${a}, ${b}, ${c}, ${d}, ${e}`)})()
  const genlet = (name, body) => {
    if (body[0]?.code === "fn" && body.type.types.find(x => x.var) && body.type.generics.length) {
      for (const a of body.type.generics) {
        const x = structuredClone(body)
        x.type = {...x.type, types: a}
        x.slice(1, -1).map((arg, i) => arg.type = a[i])
        x.type.names.map((arg, i) => arg.type = a[i])
        x.type.ret.type = a.at(-1)
        lines.push(`${name}__${a.map(gentype).join("__")} := ${gen(x)}`)
      }
    } else {
      lines.push(`${name} := ${gen(body)}`)
    }
    return ""
  }
  const genhead = x => x.type.name === "fn" && x.type.names?.find(y => y.type.var) && x.type.generics?.length ?
    `${gen(x)}__${x.type.types.map(gentype).join("__")}` : gen(x)
  const gen = x => !Array.isArray(x) ? x.code :
    x[0].code === "do"     ? x.slice(1).map(gen).join("\n") :
    x[0].code === "for"    ? (lines.push(genfor(x.slice(1).map(gen))), "") :
    x[0].code === "each"   ? (lines.push(`for _, ${x[1].code} := range ${gen(x[2])} { ${gen(x[3])} }`), "") :
    x[0].code === "while"  ? (lines.push(`for ${gen(x[1])} { ${gen(x[2])} }`), "") :
    x[0].code === "let"    ? genlet(x[1].code, x[2]) :
    x[0].code === "return" ? `__ret = ${gen(x[1])}; return` :
    x[0].code === "throw"  ? `__err = errors.New(${gen(x[1])}); return` :
    x[0].code === "catch"  ? !x[1].type.fails ? gen(x[1]) : ((id1, id2) => (lines.push(`${id1}, ${id2} := ${gen(x[1])}; if ${id2} != nil { ${id1} = ${gen(x[2])}(${id2}) }`), id1))(newId(), newId()) :
    x[0].code === "if"     ? `if ${gen(x[1])} { ${gen(x[2])} }${genif(x.slice(3))}` :
    x[0].code === "iif"    ? (id => (lines.push(`var ${id} ${gentype(x[2].type)}; ${geniif(id, x.slice(1))}`), id))(newId()) :
    x[0].code === "struct" ? (defs.push(`type ${x[1].code} ${genstruct(x.type.types.at(-1))}`), "") :
    x[0].code === "fn"     ? `${genfunc(x.type)} { ${genreturn(x.at(-1))} }` :
    x[0].code === "tuple"  ? `__tuple${x.length - 1}[${x.slice(1).map(node => gentype(node.type))}]{ ${x.slice(1).map(gen)} }` :
    x[0].code === "new"    ? `${genstruct(x.type)}{${range((x.length-1)/2).map(i => gen(x[i*2+2]))}}` :
    x[0].code === "vec"    ? `[]${gentype(x[1].type)}{ ${x.slice(1).map(gen)} }` :
    x[0].code === "map"    ? `map[${gentype(x[1].type)}]${gentype(x[2].type)}{ ${range((x.length-1)/2).map(i => `${gen(x[i*2+1])}: ${gen(x[i*2+2])}`)} }` :
    x[0].code === "set"    ? `map[${gentype(x[1].type)}]struct{}{ ${x.slice(1).map(n => `${gen(n)}: struct{}{}`)} }` :
    x[0].code === "!"      ? `${x[0].code}${gen(x[1])}` :
    x[0].type?.struct      ?  gen(x[0]) + "{" + x.slice(1).map(gen).join(", ") + "}" :
    x[0].code === "." && x[1]?.type?.name === "tuple" ? `${gen(x[1])}.v${x[2].code}` :
    x[0].code === "." && x[1]?.type?.name === "error" && x[2].code === "message" ? `${gen(x[1])}.Error()` :
    /[+\-*/%^<>!=|&.]/.test(x[0].code) ? genop(x[0].code, x.slice(1)) :
    genhead(x[0]) + "(" + x.slice(1).map(gen).join(", ") + ")"
  const exp = root.map(gen).at(-1)
  return {
    def: defs.join("\n"),
    stmt: lines.join("\n"),
    exp: exp,
    fails: root.at(-1).type?.fails
  }
}

const compile = code => generate(infer(parse(tokenize(code))))

const execGo = (cmd) => {
  const fs = require("fs")
  const {execSync} = require("child_process")
  const files = process.argv.length === 3 ? fs.globSync("**/*.moa") : process.argv.slice(3)
  const runtime = fs.readFileSync(__dirname + "/runtime.go", "utf-8")
  const x = compile(files.map(path => fs.readFileSync(path, "utf-8")).join("\n"))
  const go = `${runtime}\n${x.def}\nfunc main() { ${x.stmt}\n${x.exp} }\n`
  fs.writeFileSync("/tmp/a.go", go)
  execSync(`go ${cmd} /tmp/a.go`, {stdio: "inherit"})
}

if (process.argv[2] === "selftest") {
  process.exit(require("./test.js").test({tokenize, parse, infer, compile, TypeError}))
} else if (process.argv[2] === "version") {
  console.log("moa version 0.0.1")
} else if (process.argv[2] === "build") {
  execGo("build")
} else if (process.argv[2] === "run") {
  execGo("run")
} else {
  console.log(`Moa is a programming language

Usage: moa <command> [...arguments]

Commands:
  moa build [...files]     compile to an executable file
  moa run   [...files]     compile and run
  moa repl  [...files]     start a shell
  moa test  [...files]     run tests
  moa version              display Moa version`)
}
